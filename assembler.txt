( $ Id: )
( Copyright{2000}: Albert van der Horst, HCC FIG Holland by GNU Public License)

Introduction
------------

You find here a couple of assemblers, to complement the generic figForth system.
They are based on the postit/fixup principle.

as80.frt  : simple 8080 assembler without error detection
asgen.frt : generic part of postit/fixup assembler
as80.frt  : 8080 assembler, requires asgen.frt 
asi86.frt  : 8086 assembler, requires asgen.frt
asi586.frt : 80386 assembler, requires asgen.frt
assembler.txt : this text
ps.frt     : generate opcode sheets 
p0.asi586.ps : first byte opcode for asi586 assembler
p0F.asi586.ps : two byte opcode for same that start with 0F.
test.mak : makefile, i.e. with targets for opcode sheats.

Principle of operation
----------------------

In making an assembler for the Pentium it turns out that
the in-between-step of creation defining words for each type
of assembly gets in the way. There are just too many of them.

MASM heavily overloads the instruction, in particular MOV.
One time I criticised Intel because they had an unpleasant to use
instruction set with MOV MVR and MVI for move instructions. In
hindsight that was not too bad and I am returning to that. 
(I mean they are really different instructions, it might have been
better if they weren't. But an assembler must live up to the truth.)
Where the intel folks really go overboard is with the disambiguation of
essentially ambigous constructs, by things as `OFFSET' `BYTE POINTER'
`ASSUME' . You can no longer find out what the instruction means by itself.
The simplest example is
        INC [BX]
Are we to increment the byte or the word at BX? ( Solution : INC BYTE POINTER BX)
Contrarily here we adapt the rule : if an instruction doesn't determine the operand
size (some do, like LEA), then a size fixup is needed ( X| or B|).

This is an example of how this assembler works:
POSTIT phase:
MOV, assembles a two byte instruction with holes.
FIXUP phase 
X| or B| fits in one of the holes left.

Doesn't that lay a burden on the programmer? Yes.
He has to know exactly what he is doing.
But assembly programming is dancing on a rope. The Intel syntax tries
to hide from you were the rope is. A bad idea. There is no such thing as
assembly programming for dummies.

Advantages :
Aware of what instructions are there.
Remarks in creating the first example 8080
------------------------------------------

The 8080 assembler 
doesn't take less place than CASSADY's . (You bet that it pays of for
the Pentium, but not for the 8080.) But.. The regularities are much
more apparent. It is much more difficult to make a mistake with the
code for the ADD and ADI instructions. And there is information there
to the point that it allows to make a disassembler that is independant
of the instruction information, one that will work for the 8086, look
at the pop family.
First I had 
38 C1 02 4 1FAMILY, POP -- PUSH RST      ( B'|)
(cause I started from an existing assembler.)
But of course RST (the restart instruction) has nothing to do
with registers, so it gets a separate line.
The bottom line is : the assembler proper now takes 22 lines of code. 
Furthermore the `call conditional' and `return conditional'
instructions where missing. 
For me this means turning `jump conditional' into a family.

Opcode sheets
-------------
Using test.mak (on a linux computer in lina) you can generate opcode sheets
by  "make asi586.ps". For the opcode sheets featuring a n-byte prefix you must
pass the PREFIX to make and a MASK that covers the prefix and the byte opcode, e.g.
make asi586.ps MASK=FFFF PREFIX=0F
The opcode sheets p0.asi586.ps and p0F.asi586.ps are already made and can be 
printed on a postscript printer or viewed with e.g. 'gv'.

Compare the opcode sheets with Intel's to get an overview of what I have done 
to the instruction set. In essence I have reengineered it to make it reverse 
assemblable, i.e. from a disassembly you can regenerate the machine code.
This is NOT true for Intels instruction set, e.g. Intel has the same opcode for
MOV, X| T| AX'| R| BX|      and MOV, X| F| BX'| R| AX|
and for
IMUL|AD, X| R| BX|              IMUL, AX'| R| BX|
( GNU's objdump gives the same disassembly for both imul's despite the difference 
between a 32*32 > 64 and a 32*32 > 32 operation.).

To get a reminder of what instructions there are type SHOW-OPCODES.
If you are a bit familiar with the opcodes you are almost there. For if you want to 
know what the precides instruction format of e.g. IMUL|AD, just type 
SHOW: IMUL|AD,
You can also type SHOW-ALL, but that takes a lot of time and is more intended for 
test purposes.

Details about the 80386 instructions
------------------------------------

Read the introductory comment of asgen.frt for how the assembler
keeps track of the state, using the BI BY BA tallies.

1. A word ending in , reserves place in the dictionary.
It stand for one assembler instruction. 
The start of the instruction is kept and there is a bitfield (the tally) for
all bits that belong to the instruction, if only mentally. These bits are
put as comment in front of the instruction and they are considered filled
in. They also imply the instruction length. 
2. A word ending in | is a fixup, it and's in some bits
in an already assembled instruction. Again there is a mask in front
of fixups and in using the fixup these bits are considered to be filled
in. A fixup cannot touch data before the start of the latest instruction.
3. Families can be constructed from instructions or fixups with the
same tally bit field, provided they differ by a fixed increment. If
data or addresses following differ this is unwise. 
4. The part before a possible | in an instruction -- but exluding an
optional trailing I -- is the opcode. Opcodes define indeed a same action.
5. The part after | in an instruction may be considered a built in
fixup where irregularity forbids to use a real fixup.
A X stands for xell or natural data width. This is 16 bit for a
16 bit assembler and 32 bit for a 32 bit assembler. These can be 
overruled with AS:, applying to DX| and MEM| and with OS:, applying to
data required where there is an I suffix.
6 Width fixups determine the data width : X| 
(xell or natural data width 16/32 ) or B| ( 8 bit) unless implied.
6. Instruction ending in I have an immediate data field after all 
fixups. This can be either X, (xell or natural data width) or
B, W, L, ( 8 16 32 bit). 
If there are width fixups they should correspond with the data.
* Instructions ending in |SEG builtin fixup (segments) require SEG,
(which is always 16 bits).
C If X, cannot be used caused by width overrules, the programmer should
carefully insert W, or L, whatever appropriate. 
*. Instructions with r/m can have offsets (for DB| and DX| ) that must
be assembled using B, or X, but mind the previous point.
*. Instruction with r/m can have a register instead of memory indicated
by the normal fixups AX| etc.
* If instructions with r/m have another register, that one is indicated
by primed registers AX'| Or if an instruction can handle two general
registers, the one that cannot be replace by a memory reference gets a prime.
* Unless T| F| (to/from) present a primed register is the modifiable one,
else T| F| refer to the primed register. The primed register is the one         
that cannot be replace by a memory reference.
7. At the start of an instruction the mask of the previous instruction
plus fixup should add up non-overlappingly to a full field.
Offsets and immediate data should have been commaed in in that order.
8. A fixup or instruction
is mightier than an other one 
if its mask contains all the bits of that other one.
The second fixup or instruction
shall then not be used.
9. Instructions ending in :, are prefixes and are considered in their own
right. They have no fixups.
10. The Scaled Index Byte is handled in the following way:
The fixup SIB| closes the previous instruction (i.e.
fill up its bit field), but possible immediate data and offsets are kept.
Then SIB, starts a new instruction. 
* The SET, instruction unfortunately requires a duplicate of the
O| etc. fixups of the J, and J|X, instructions.
* Some single byte instructions require X'| and B'| instead of X| and B|
that are used for the ubiquitous instructions with r/m.
11. Hand disambling can be done as follows.
  I Find the mightiest instruction that agrees with the data at the
    program counter. Tally the bits. The instructions length follows from
    the instruction. As does the presence of address offsets and immediate
    data. The dictionary may b eorganized such that the mightiest
    instruction is always found first.
  II Find the mightiest fixup that agrees with untallied bits.
  III If not all bits have been tallied go to II
  IV Disassemble the address offsets and immediate data, in accordance
     with the instruction. Length is determined from fixups and prefix 
     bytes.
The result must agree with the instruction in the first place.

Using 16 bits code in the 32 bit assembler
------------------------------------------

In general X refers to Xell. So in 16 bit mode or with a 16 bit prefix
AX is to mean the Intel AX instead of what is normal EAX.
It is thus possible to insert a patch of 16 bit code in 32 bit code
all with the 32 bit assembler. This can be necessary in system
programming. Just use "MOV, AX'| R| BX|" and in 16 bit mode it refers
to 16 bit registers.

If an address overwrite suffix applies, the indexing fixups ending in
a prime must be used, e.g. [BX+SI]' instead of [AX] for code running
in a default 32 bit environment. (Otherwise use the 8086 assembler)
But during system programming only the programmer knows what is going on,
so some error messages are suppressed.

While using 16 bits code, whenever you get error messages and you 
are sure you know better than the assembler, put !TALLY before the
word that gives the error messages.

This assembler is not yet integrated in the generic Forth
---------------------------------------------------------

In the generic Forth automatically a 32 bit assembler is loaded if the
Forth itself is 32 bits and a 16 bit assembler for the 16 bit forths. 
Adding the extra complexity to run the 16 bit assembler on a 32 bit
system would be the drip that overflows the bucket. This is no
restriction for what code can be generated. 
THE BUILT IN ASSEMBLER HAS NO ERROR CHECKING AND HAS MANY ERRORS
THAT THE VERY EXTENSIVELY TESTED "asi586.frt" HAS NOT.

A last rant about redundancy
----------------------------

Reduncancy make bad instructions look bad.
What about 
MOV, B| T| [BX+SI] R| AX|
MOV, needs two operands 
but there is no primary operand in sight. [BX+SI] would not qualify.
and not even BX| because the primary operand should be 
marked with a prime.
MOV, X| T| BX| AX|
looks bad because you know BX| and AX| work on the same bit fields,
so it easy to remember you need the prime.
T| and F| refer to the primary operands, so gone is the endless confusion
about what is the destination of the move.
MOV, X| T| BX'| R| AL| looks bad , because you AL| could not possibly qualify
as an X register. 
MOV, X| T| BX'| AX| looks bad , because soon you will adopt the habit
that one of the 8 main reigster always must be preceeded with T| F| or R|.

MOV, X| T| BX'| R| AX| looks right but you still can code
MOV, AX| BX'| R| T| X| 
if you prefer your fixups in alphabetic order. (A nice rule for those
Code Standard Police out there?).
And yest
ES: OS: MOV, X| T| DI'| sib|, DX| [BP +8* AX] FFFFF800 X,
though being correct, 
looks still bad, because it *is* bad in the sense that the Pentium design
got overboard in complication.
First remark lets assume this is 
32 bit code,(because otherwise there
would not be a sib, sure?)
There are 3 sizes involved : 
The size of the data transported this is always the X as in X|.
Then the first X| changes its meaning to 16 bit, because of the OS:
prefix. 
The X in DX| and in X, must agree and are 32 bits because you are in 
a 32 bits segment and this cannot be overridden.
The offset (in +AX]) is counted in 64 bits, a strange array fro fetching
the DI but anyway.
And .. by the way the data is placed in the extra segment.
Add a bit of awareness of the cost of the instructions in execution time
and take care of the difference between the Pentium processors MMX en III
and what not and you will see that assembly program is not for the faint
of heart. The ASSUME of the MASM assembler buys you nothing, but 
inconvenience.


